{{- ## The generated code is whitespace-normalized,
the template therefore doesn't have to worry about whitespace. ## -}}

{{ func render_node(node, parent, parent_members) }}

    public {{ if node.is_variant }} abstract {{ else }} sealed {{ end }} record {{ node.name }}
    {{ $members = array.add_range parent_members node.members }}
    {{ if $members.size != 0 }}
        (
        {{ for member in $members }}
            {{ if member.is_list }}
                ImmutableArray<{{ member.type }}>
            {{ else }}
                {{ member.type }}
            {{ end }}
            {{ if member.is_optional }}
                ?
            {{ end }}
            {{ member.name }}
            {{ if !for.last }}
                ,
            {{ end }}
        {{ end }}
        )
    {{ end }}
    {{ if parent != null }}
        : {{ parent.name }}
        {{ if parent_members.size != 0 }}
            (
            {{ for member in parent_members }}
                {{ member.name }}
                {{ if !for.last }}
                    ,
                {{ end }}
            {{ end }}
            )
        {{ end }}
    {{ end }}
    {{ if !node.is_variant }}
    ;
    {{ else }}
    {
        {{ for child in node.nodes }}
            {{ render_node child node $members }}
        {{ end }}
    }
    {{ end }}

{{ end }}



{{ func render_member_visits(members) }}

    {{ for member in members }}
        {{ if !member.is_primitive }}
            {{ if member.is_list }}
                VisitMany(node.{{ member.name }});
            {{ else }}
                VisitNode(node.{{ member.name }});
            {{ end }}
        {{ end }}
    {{ end }}

{{ end }}



{{ func render_visitor_method(node, parents) }}

    {{ $type_name = type_name node parents }}
    {{ $method_name = method_name node parents }}
    {{ $new_parents = array.add parents node }}

    public T {{ $method_name }}({{ $type_name }} node)
    {{ if node.is_variant }}
        => node switch
        {
        {{ for child in node.nodes }}
            {{ type_name child $new_parents }} x => {{ method_name child $new_parents }}(x),
        {{ end }}
        _ => throw new UnreachableException()
        };

        {{ for child in node.nodes }}
            {{ render_visitor_method child $new_parents }}
        {{ end }}
    {{ else }}
        {
        {{ render_member_visits node.members }}
        return Default;
        }
    {{ end }}

{{ end }}



{{ func render_visitor_void_method(node, parents) }}

    {{ $type_name = type_name node parents }}
    {{ $method_name = method_name node parents }}
    {{ $new_parents = array.add parents node }}

    public virtual void {{ $method_name }}({{ $type_name }} node)
    {{ if node.is_variant }}
        {
        switch (node)
        {
        {{ for child in node.nodes }}
            case {{ type_name child $new_parents }} x:
            {{ method_name child $new_parents }}(x);
            break;
        {{ end }}
        default: throw new UnreachableException();
        }
        }

        {{ for child in node.nodes }}
            {{ render_visitor_void_method child $new_parents }}
        {{ end }}
    {{ else }}
        {
        {{ render_member_visits node.members }}
        }
    {{ end }}

{{ end }}



using System.Diagnostics.CodeAnalysis;

namespace Stifl;

#nullable enable

#pragma warning disable CS0108

{{ render_node root null [] }}

public abstract class {{ root.name }}Visitor<T> where T : notnull
{
    protected abstract T Default { get; }

    protected virtual void BeforeVisit({{ root.name }} node) {}

    protected virtual void AfterVisit({{ root.name }} node) {}

    protected virtual bool Filter({{ root.name }} node) => true;

    public IReadOnlyList<T> VisitMany<TNode>(IEnumerable<TNode> nodes) where TNode : {{ root.name }} => nodes.Select(VisitNode).ToList()!;

    [return: NotNullIfNotNull(nameof(node))]
    public virtual T? VisitNode({{ root.name }}? node)
    {
        if (node is null) return default;

        if (!Filter(node)) return Default;

        BeforeVisit(node);
        var x = Visit{{ root.name }}(node);
        AfterVisit(node);

        return x;
    }

    {{ render_visitor_method root [] }}
}

public abstract class {{ root.name }}Visitor
{
    protected virtual void BeforeVisit({{ root.name }} node) {}

    protected virtual void AfterVisit({{ root.name }} node) {}

    protected virtual bool Filter({{ root.name }} node) => true;

    public void VisitMany<TNode>(IEnumerable<TNode> nodes) where TNode : {{ root.name }}
    {
        foreach (var x in nodes) VisitNode(x);
    }

    public virtual void VisitNode({{ root.name }}? node)
    {
        if (node is null) return;

        if (!Filter(node)) return;

        BeforeVisit(node);
        Visit{{ root.name }}(node);
        AfterVisit(node);
    }

    {{ render_visitor_void_method root [] }}
}
